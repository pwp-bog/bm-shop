<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ElementNumbersDontMatch" xml:space="preserve">
    <value>Le nombre d'éléments dans les collections ne correspond pas. Attendu : &lt;{1}&gt;, Réel : &lt;{2}&gt;.{0}</value>
  </data>
  <data name="IsMatchFail" xml:space="preserve">
    <value>La chaîne '{0}' ne correspond pas au modèle '{1}'. {2}.</value>
  </data>
  <data name="IsInstanceOfFailMsg" xml:space="preserve">
    <value>{0}Type attendu :&lt;{1}&gt;. Type réel :&lt;{2}&gt;.</value>
  </data>
  <data name="ContainsFail" xml:space="preserve">
    <value>La chaîne '{0}' ne contient pas la chaîne '{1}'. {2}.</value>
  </data>
  <data name="StartsWithFail" xml:space="preserve">
    <value>La chaîne '{0}' ne commence pas par la chaîne '{1}'. {2}.</value>
  </data>
  <data name="AreEqualDifferentTypesFailMsg" xml:space="preserve">
    <value>Attendu : &lt;{1} ({2})&gt;, Réel : &lt;{3} ({4})&gt;. {0}</value>
  </data>
  <data name="DynamicDataInvalidPropertyLayout" xml:space="preserve">
    <value>La propriété de données dynamiques « {0} » doit être statique et avoir un getter.</value>
  </data>
  <data name="BothSameElements" xml:space="preserve">
    <value>Les deux collections contiennent les mêmes éléments. {0}</value>
  </data>
  <data name="DynamicDataValueNull" xml:space="preserve">
    <value>La valeur retournée par la propriété ou la méthode {0} ne doit pas être Null.</value>
  </data>
  <data name="AreNotEqualDeltaFailMsg" xml:space="preserve">
    <value>Différence attendue supérieure à &lt;{3}&gt; comprise entre la valeur attendue &lt;{1}&gt; et la valeur réelle &lt;{2}&gt;. {0}</value>
  </data>
  <data name="ElementsAtIndexDontMatch" xml:space="preserve">
    <value>Les éléments à l'index {0} ne correspondent pas.</value>
  </data>
  <data name="BothCollectionsSameReference" xml:space="preserve">
    <value>Les deux collections Reference pointent vers le même objet Collection. {0}</value>
  </data>
  <data name="AsyncUITestMethodNotSupported" xml:space="preserve">
    <value>async TestMethod avec UITestMethodAttribute ne sont pas pris en charge. Supprimez async ou utilisez TestMethodAttribute.</value>
  </data>
  <data name="PrivateAccessorConstructorNotFound" xml:space="preserve">
    <value>
      Le constructeur doté de la signature spécifiée est introuvable. Vous devrez peut-être régénérer votre accesseur private,
      ou le membre est peut-être private et défini sur une classe de base. Si le dernier cas est vrai, vous devez transmettre le type
      qui définit le membre dans le constructeur de PrivateObject.
    </value>
  </data>
  <data name="AssertionFailed" xml:space="preserve">
    <value>Échec de {0}. {1}</value>
  </data>
  <data name="DoNotUseAssertEquals" xml:space="preserve">
    <value>Assert.Equals ne doit pas être utilisé pour les assertions. Utilisez Assert.AreEqual &amp; overloads à la place.</value>
  </data>
  <data name="UTF_TestMethodNoExceptionDefault" xml:space="preserve">
    <value>La méthode de test n'a pas levé d'exception. Une exception était attendue par l'attribut {0} défini sur la méthode de test.</value>
  </data>
  <data name="Common_NullInMessages" xml:space="preserve">
    <value>(null)</value>
  </data>
  <data name="UTF_TestMethodWrongExceptionDerivedAllowed" xml:space="preserve">
    <value>La méthode de test a levé l'exception {0}, mais l'exception {1} (ou un type dérivé de cette dernière) était attendue. Message d'exception : {2}</value>
  </data>
  <data name="NoExceptionThrown" xml:space="preserve">
    <value>Aucune exception levée. Exception {1} attendue. {0}</value>
  </data>
  <data name="DataDrivenResultDisplayName" xml:space="preserve">
    <value>{0} ({1})</value>
  </data>
  <data name="CollectionEqualReason" xml:space="preserve">
    <value>{0}({1})</value>
  </data>
  <data name="AccessStringInvalidSyntax" xml:space="preserve">
    <value>La chaîne Access possède une syntaxe non valide.</value>
  </data>
  <data name="ElementTypesAtIndexDontMatch" xml:space="preserve">
    <value>L'élément à l'index {1} n'est pas du type attendu. Type attendu : &lt;{2}&gt;, Type réel : &lt;{3}&gt;.{0}</value>
  </data>
  <data name="AreNotEqualFailMsg" xml:space="preserve">
    <value>Toute valeur attendue sauf :&lt;{1}&gt;. Réel :&lt;{2}&gt;. {0}</value>
  </data>
  <data name="AsyncUITestMethodWithNoDispatcherQueue" xml:space="preserve">
    <value>UITestMethodAttribute.DispatcherQueue ne doit pas avoir la valeur nul. Pour utiliser UITestMethodAttribute dans une application de bureau WinUI, n’oubliez pas de définir l’UITestMethodAttribute.DispatcherQueue statique pendant l’initialisation du test.</value>
  </data>
  <data name="UTF_TestMethodNoException" xml:space="preserve">
    <value>La méthode de test n'a pas levé l'exception attendue {0}. {1}</value>
  </data>
  <data name="IsNotMatchFail" xml:space="preserve">
    <value>La chaîne '{0}' correspond au modèle '{1}'. {2}.</value>
  </data>
  <data name="UTF_TestMethodWrongException" xml:space="preserve">
    <value>La méthode de test a levé l'exception {0}, mais l'exception {1} était attendue. Message d'exception : {2}</value>
  </data>
  <data name="WrongExceptionThrown" xml:space="preserve">
    <value>L'exception {2} a été levée, mais l'exception {1} était attendue. {0}
Message d'exception : {3}
Trace de la pile : {4}</value>
  </data>
  <data name="IsNotInstanceOfFailMsg" xml:space="preserve">
    <value>Type incorrect : &lt;{1}&gt;, Type réel : &lt;{2}&gt;. {0}</value>
  </data>
  <data name="AreEqualDeltaFailMsg" xml:space="preserve">
    <value>Différence attendue non supérieure à &lt;{3}&gt; comprise entre la valeur attendue &lt;{1}&gt; et la valeur réelle &lt;{2}&gt;. {0}</value>
  </data>
  <data name="UTF_FailedToGetExceptionMessage" xml:space="preserve">
    <value>(Échec de la réception du message pour une exception de type {0} en raison d'une exception.)</value>
  </data>
  <data name="AllItemsAreUniqueFailMsg" xml:space="preserve">
    <value>Un élément dupliqué a été trouvé : &lt;{1}&gt;. {0}</value>
  </data>
  <data name="Common_ObjectString" xml:space="preserve">
    <value>(objet)</value>
  </data>
  <data name="ArgumentXMustDeriveFromClassY" xml:space="preserve">
    <value>Impossible d'assigner le type '{0}' à '{1}'.</value>
  </data>
  <data name="EndsWithFail" xml:space="preserve">
    <value>La chaîne '{0}' ne se termine pas par la chaîne '{1}'. {2}.</value>
  </data>
  <data name="DynamicDataIEnumerableEmpty" xml:space="preserve">
    <value>La propriété ou la méthode {0} sur {1} retourne un IEnumerable&lt;object[]&gt; vide.</value>
  </data>
  <data name="DynamicDataInvalidMethodLayout" xml:space="preserve">
    <value>La méthode de données dynamiques « {0} » doit être statique, sans paramètre et non générique.</value>
  </data>
  <data name="NumberOfElementsDiff" xml:space="preserve">
    <value>Nombre d'éléments différent.</value>
  </data>
  <data name="NullParameterToAssert" xml:space="preserve">
    <value>Le paramètre '{0}' n'est pas valide. La valeur ne peut pas être null. {1}.</value>
  </data>
  <data name="BothCollectionsSameElements" xml:space="preserve">
    <value>Les deux collections contiennent des éléments identiques.</value>
  </data>
  <data name="BothCollectionsEmpty" xml:space="preserve">
    <value>Les deux collections sont vides. {0}</value>
  </data>
  <data name="AreEqualCaseFailMsg" xml:space="preserve">
    <value>Attendu :&lt;{1}&gt;. La casse est différente pour la valeur réelle :&lt;{2}&gt;. {0}</value>
  </data>
  <data name="InvalidPropertyType" xml:space="preserve">
    <value>La propriété {0} possède le type {1} ; type attendu {2}.</value>
  </data>
  <data name="AreSameGivenValues" xml:space="preserve">
    <value>Ne passez pas de types valeur à AreSame(). Les valeurs converties en Object ne seront plus jamais les mêmes. Si possible, utilisez AreEqual(). {0}</value>
  </data>
  <data name="DynamicDataIEnumerableNull" xml:space="preserve">
    <value>La propriété ou la méthode {0} sur le type de retour {1} ne peut pas être attribuée à « IEnumerable&lt;object[]&gt; » (ni à « IEnumerable&lt;ITuple&gt; » pour .NET Core).</value>
  </data>
  <data name="UTF_ExpectedExceptionTypeMustDeriveFromException" xml:space="preserve">
    <value>Le type de l'exception attendue doit être System.Exception ou un type dérivé de System.Exception.</value>
  </data>
  <data name="DynamicDataDisplayName" xml:space="preserve">
    <value>La méthode {0} doit correspondre à la signature attendue : public static {1} {0}({2}).</value>
  </data>
  <data name="AreEqualFailMsg" xml:space="preserve">
    <value>Attendu : &lt;{1}&gt;, Réel : &lt;{2}&gt;. {0}</value>
  </data>
  <data name="ActualHasMismatchedElements" xml:space="preserve">
    <value>La collection attendue contient {1} occurrence(s) de &lt;{2}&gt;. La collection réelle contient {3} occurrence(s). {0}</value>
  </data>
  <data name="PrivateAccessorMemberNotFound" xml:space="preserve">
    <value>
      Le membre spécifié ({0}) est introuvable. Vous devrez peut-être régénérer votre accesseur private,
      ou le membre est peut-être private et défini sur une classe de base. Si le dernier cas est vrai, vous devez transmettre le type
      qui définit le membre dans le constructeur de PrivateObject.
    </value>
  </data>
</root>