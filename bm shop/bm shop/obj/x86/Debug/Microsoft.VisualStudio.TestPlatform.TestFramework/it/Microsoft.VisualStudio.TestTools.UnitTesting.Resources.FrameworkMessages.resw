<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ElementNumbersDontMatch" xml:space="preserve">
    <value>Il numero di elementi nelle raccolte non corrisponde. Previsto:&lt;{1}&gt;. Effettivo:&lt;{2}&gt;.{0}</value>
  </data>
  <data name="IsMatchFail" xml:space="preserve">
    <value>La stringa '{0}' non corrisponde al criterio '{1}'. {2}.</value>
  </data>
  <data name="IsInstanceOfFailMsg" xml:space="preserve">
    <value>{0} Tipo previsto:&lt;{1}&gt;. Tipo effettivo:&lt;{2}&gt;.</value>
  </data>
  <data name="ContainsFail" xml:space="preserve">
    <value>La stringa '{0}' non contiene la stringa '{1}'. {2}.</value>
  </data>
  <data name="StartsWithFail" xml:space="preserve">
    <value>La stringa '{0}' non inizia con la stringa '{1}'. {2}.</value>
  </data>
  <data name="AreEqualDifferentTypesFailMsg" xml:space="preserve">
    <value>Previsto:&lt;{1} ({2})&gt;. Effettivo:&lt;{3} ({4})&gt;. {0}</value>
  </data>
  <data name="DynamicDataInvalidPropertyLayout" xml:space="preserve">
    <value>La proprietà '{0}' di Dynamic Data deve essere statica e avere un getter.</value>
  </data>
  <data name="BothSameElements" xml:space="preserve">
    <value>Le raccolte contengono entrambe gli stessi elementi. {0}</value>
  </data>
  <data name="DynamicDataValueNull" xml:space="preserve">
    <value>Il valore restituito dalla proprietà o dal metodo {0} non deve essere Null.</value>
  </data>
  <data name="AreNotEqualDeltaFailMsg" xml:space="preserve">
    <value>Prevista una differenza maggiore di &lt;{3}&gt; tra il valore previsto &lt;{1}&gt; e il valore effettivo &lt;{2}&gt;. {0}</value>
  </data>
  <data name="ElementsAtIndexDontMatch" xml:space="preserve">
    <value>L'elemento alla posizione di indice {0} non corrisponde.</value>
  </data>
  <data name="BothCollectionsSameReference" xml:space="preserve">
    <value>I riferimenti a raccolte puntano entrambi allo stesso oggetto Collection. {0}</value>
  </data>
  <data name="AsyncUITestMethodNotSupported" xml:space="preserve">
    <value>L'elemento async TestMethod con UITestMethodAttribute non è supportato. Rimuovere async o usare TestMethodAttribute.</value>
  </data>
  <data name="PrivateAccessorConstructorNotFound" xml:space="preserve">
    <value>
      Il costruttore con la firma specificata non è stato trovato. Potrebbe essere necessario rigenerare la funzione di accesso privata
      oppure il membro potrebbe essere privato e definito per una classe base. In quest'ultimo caso, è necessario passare il tipo
      che definisce il membro nel costruttore di PrivateObject.
    </value>
  </data>
  <data name="AssertionFailed" xml:space="preserve">
    <value>{0} non riuscita. {1}</value>
  </data>
  <data name="DoNotUseAssertEquals" xml:space="preserve">
    <value>Non è possibile usare Assert.Equals per le asserzioni. Usare Assert.AreEqual e gli overload.</value>
  </data>
  <data name="UTF_TestMethodNoExceptionDefault" xml:space="preserve">
    <value>Il metodo di test non ha generato un'eccezione. È prevista un'eccezione dall'attributo {0} definito nel metodo di test.</value>
  </data>
  <data name="Common_NullInMessages" xml:space="preserve">
    <value>(Null)</value>
  </data>
  <data name="UTF_TestMethodWrongExceptionDerivedAllowed" xml:space="preserve">
    <value>Il metodo di test ha generato l'eccezione {0}, ma era prevista l'eccezione {1} o un tipo derivato da essa. Messaggio dell'eccezione: {2}</value>
  </data>
  <data name="NoExceptionThrown" xml:space="preserve">
    <value>Non è stata generata alcuna eccezione. Era prevista un'eccezione {1}. {0}</value>
  </data>
  <data name="DataDrivenResultDisplayName" xml:space="preserve">
    <value>{0} ({1})</value>
  </data>
  <data name="CollectionEqualReason" xml:space="preserve">
    <value>{0}({1})</value>
  </data>
  <data name="AccessStringInvalidSyntax" xml:space="preserve">
    <value>La sintassi della stringa di accesso non è valida.</value>
  </data>
  <data name="ElementTypesAtIndexDontMatch" xml:space="preserve">
    <value>L'elemento nell'indice {1} non è del tipo previsto. Tipo previsto:&lt;{2}&gt;. Tipo effettivo:&lt;{3}&gt;.{0}</value>
  </data>
  <data name="AreNotEqualFailMsg" xml:space="preserve">
    <value>Previsto qualsiasi valore tranne:&lt;{1}&gt;. Effettivo:&lt;{2}&gt;. {0}</value>
  </data>
  <data name="AsyncUITestMethodWithNoDispatcherQueue" xml:space="preserve">
    <value>UITestMethodAttribute.DispatcherQueue non deve essere Null. Per usare UITestMethodAttribute all'interno di un'app desktop WinUI, ricordarsi di impostare il parametro statico uiTestMethodAttribute.DispatcherQueue durante l'inizializzazione del test.</value>
  </data>
  <data name="UTF_TestMethodNoException" xml:space="preserve">
    <value>Il metodo di test non ha generato l'eccezione prevista {0}. {1}</value>
  </data>
  <data name="IsNotMatchFail" xml:space="preserve">
    <value>La stringa '{0}' corrisponde al criterio '{1}'. {2}.</value>
  </data>
  <data name="UTF_TestMethodWrongException" xml:space="preserve">
    <value>Il metodo di test ha generato l'eccezione {0}, ma era prevista l'eccezione {1}. Messaggio dell'eccezione: {2}</value>
  </data>
  <data name="WrongExceptionThrown" xml:space="preserve">
    <value>È stata generata l'eccezione {2}, ma era prevista un'eccezione {1}. {0}
Messaggio dell'eccezione: {3}
Analisi dello stack: {4}</value>
  </data>
  <data name="IsNotInstanceOfFailMsg" xml:space="preserve">
    <value>Tipo errato:&lt;{1}&gt;. Tipo effettivo:&lt;{2}&gt;. {0}</value>
  </data>
  <data name="AreEqualDeltaFailMsg" xml:space="preserve">
    <value>Prevista una differenza non maggiore di &lt;{3}&gt; tra il valore previsto &lt;{1}&gt; e il valore effettivo &lt;{2}&gt;. {0}</value>
  </data>
  <data name="UTF_FailedToGetExceptionMessage" xml:space="preserve">
    <value>Non è stato possibile ottenere il messaggio per un'eccezione di tipo {0} a causa di un'eccezione.</value>
  </data>
  <data name="AllItemsAreUniqueFailMsg" xml:space="preserve">
    <value>Rilevato elemento duplicato:&lt;{1}&gt;. {0}</value>
  </data>
  <data name="Common_ObjectString" xml:space="preserve">
    <value>(oggetto)</value>
  </data>
  <data name="ArgumentXMustDeriveFromClassY" xml:space="preserve">
    <value>Il tipo '{0}' non è assegnabile a '{1}'.</value>
  </data>
  <data name="EndsWithFail" xml:space="preserve">
    <value>La stringa '{0}' non termina con la stringa '{1}'. {2}.</value>
  </data>
  <data name="DynamicDataIEnumerableEmpty" xml:space="preserve">
    <value>La proprietà o il metodo {0} nella classe {1} restituisce un elemento IEnumerable&lt;object[]&gt; vuoto.</value>
  </data>
  <data name="DynamicDataInvalidMethodLayout" xml:space="preserve">
    <value>Il metodo '{0}' di Dynamic Data deve essere statico, senza parametri e non generico.</value>
  </data>
  <data name="NumberOfElementsDiff" xml:space="preserve">
    <value>Il numero di elementi è diverso.</value>
  </data>
  <data name="NullParameterToAssert" xml:space="preserve">
    <value>Il parametro '{0}' non è valido. Il valore non può essere Null. {1}.</value>
  </data>
  <data name="BothCollectionsSameElements" xml:space="preserve">
    <value>Le raccolte contengono entrambe gli stessi elementi.</value>
  </data>
  <data name="BothCollectionsEmpty" xml:space="preserve">
    <value>Le raccolte sono entrambe vuote. {0}</value>
  </data>
  <data name="AreEqualCaseFailMsg" xml:space="preserve">
    <value>Previsto:&lt;{1}&gt;. La combinazione di maiuscole e minuscole è diversa per il valore effettivo:&lt;{2}&gt;. {0}</value>
  </data>
  <data name="InvalidPropertyType" xml:space="preserve">
    <value>Il tipo della proprietà {0} è {1}, ma quello previsto è {2}.</value>
  </data>
  <data name="AreSameGivenValues" xml:space="preserve">
    <value>Non passare tipi valore a AreSame(). I valori convertiti in Object non saranno mai uguali. Usare AreEqual(). {0}</value>
  </data>
  <data name="DynamicDataIEnumerableNull" xml:space="preserve">
    <value>La proprietà o il metodo {0} su {1} tipo restituito non è assegnabile a 'IEnumerable&lt;object[]&gt;' (né a 'IEnumerable&lt;ITuple&gt;' per .NET Core).</value>
  </data>
  <data name="UTF_ExpectedExceptionTypeMustDeriveFromException" xml:space="preserve">
    <value>Il tipo di eccezione previsto deve essere System.Exception o un tipo derivato da System.Exception.</value>
  </data>
  <data name="DynamicDataDisplayName" xml:space="preserve">
    <value>Il metodo {0} deve corrispondere alla firma prevista: public static {1} {0}({2}).</value>
  </data>
  <data name="AreEqualFailMsg" xml:space="preserve">
    <value>Previsto:&lt;{1}&gt;. Effettivo:&lt;{2}&gt;. {0}</value>
  </data>
  <data name="ActualHasMismatchedElements" xml:space="preserve">
    <value>La raccolta prevista contiene {1} occorrenza/e di &lt;{2}&gt;. La raccolta effettiva contiene {3} occorrenza/e. {0}</value>
  </data>
  <data name="PrivateAccessorMemberNotFound" xml:space="preserve">
    <value>
      Il membro specificato ({0}) non è stato trovato. Potrebbe essere necessario rigenerare la funzione di accesso privata
      oppure il membro potrebbe essere privato e definito per una classe base. In quest'ultimo caso, è necessario passare il tipo
      che definisce il membro nel costruttore di PrivateObject.
    </value>
  </data>
</root>