<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ExceptionOccuredWhileGettingTheExceptionDescription" xml:space="preserve">
    <value>"{0}": (Не удалось получить описание исключения из-за исключения типа "{1}".</value>
  </data>
  <data name="CannotExpandIDataSourceAttribute" xml:space="preserve">
    <value>Возникло исключение при развертывании строк IDataSource из атрибута "{0}.{1}": {2}</value>
  </data>
  <data name="UTA_AssemblyCleanupMethodWasUnsuccesful" xml:space="preserve">
    <value>Не удалось применить метод очистки сборки {0}.{1}. Сообщение об ошибке: {2}. Трассировка стека (StackTrace): {3}.</value>
  </data>
  <data name="TestCleanupTimedOut" xml:space="preserve">
    <value>Истекло время ожидания метода очистки теста "{0}.{1}"</value>
  </data>
  <data name="Execution_Test_Cancelled" xml:space="preserve">
    <value>Выполнение теста "{0}" было прервано.</value>
  </data>
  <data name="AssemblyCleanupWasCancelled" xml:space="preserve">
    <value>Метод очистки сборки "{0}.{1}" отменен</value>
  </data>
  <data name="DiscoveryWarning" xml:space="preserve">
    <value>[MSTest][Discovery][{0}] {1}</value>
  </data>
  <data name="InvalidSettingsXmlElement" xml:space="preserve">
    <value>Недопустимые параметры "{0}". Непредвиденный элемент XmlElement: "{1}".</value>
  </data>
  <data name="TestContextMessageBanner" xml:space="preserve">
    <value>Сообщения TestContext:</value>
  </data>
  <data name="UTA_TestInitializeAndCleanupMethodHasWrongSignature" xml:space="preserve">
    <value>Метод {0}.{1} имеет неправильную сигнатуру. Метод должен быть нестатическим и открытым, не должен возвращать значение и принимать параметры. Кроме того, при использовании async-await в методе возвращаемое значение должно иметь тип "Task" или "ValueTask".</value>
  </data>
  <data name="UTA_ErrorTestClassIsGenericNonAbstract" xml:space="preserve">
    <value>Атрибут TestClass, определенный в универсальном не абстрактном классе {0}</value>
  </data>
  <data name="UTA_ClassOrAssemblyInitializeMethodHasWrongSignature" xml:space="preserve">
    <value>Метод {0}.{1} имеет неправильную сигнатуру. Метод должен быть статическим и открытым, не должен возвращать значение и должен принимать один параметр, имеющий тип TestContext. Кроме того, при использовании async-await в методе возвращаемое значение должно иметь тип "Task" или "ValueTask".</value>
  </data>
  <data name="CannotEnumerateIDataSourceAttribute" xml:space="preserve">
    <value>Возникло исключение при перечислении атрибута IDataSource в "{0}.{1}": {2}</value>
  </data>
  <data name="InvalidSettingsXmlAttribute" xml:space="preserve">
    <value>Недопустимые параметры "{0}". Непредвиденный атрибут XmlAttribute: "{1}".</value>
  </data>
  <data name="UTA_ErrorMultiAssemblyInit" xml:space="preserve">
    <value>UTA013: {0}: в сборке невозможно определить несколько методов с атрибутом AssemblyInitialize.</value>
  </data>
  <data name="UTA_ErrorMultiClassInit" xml:space="preserve">
    <value>UTA025: {0}: в классе невозможно определить несколько методов с атрибутом ClassInitialize.</value>
  </data>
  <data name="UTA_ExpectedExceptionAttributeConstructionException" xml:space="preserve">
    <value>Атрибут ExpectedException, определенный в методе теста {0}.{1}, породил исключение во время создания.
{2}</value>
  </data>
  <data name="TestCleanupWasCancelled" xml:space="preserve">
    <value>Метод очистки теста "{0}.{1}" отменен</value>
  </data>
  <data name="UTA_ErrorPredefinedTestProperty" xml:space="preserve">
    <value>UTA023: {0}: не удается определить предопределенное свойство {2} в методе {1}.</value>
  </data>
  <data name="UTA_InitMethodThrows" xml:space="preserve">
    <value>Метод инициализации {0}.{1} вызвал исключение. {2}.</value>
  </data>
  <data name="ClassCleanupWasCancelled" xml:space="preserve">
    <value>Метод очистки класса "{0}.{1}" отменен</value>
  </data>
  <data name="TestNotFound" xml:space="preserve">
    <value>Метод теста {0} не найден.</value>
  </data>
  <data name="OlderTFMVersionFoundClassCleanup" xml:space="preserve">
    <value>В сборку загружена старая версия пакета MSTestV2. Методы очистки тестов могут выполняться неправильно. Убедитесь, что все тестовые проекты ссылаются на пакеты MSTest с версией выше 2.2.8.</value>
  </data>
  <data name="Execution_Test_Timeout" xml:space="preserve">
    <value>Превышено время ожидания выполнения теста "{0}".</value>
  </data>
  <data name="UTA_UserCodeThrewNullValueException" xml:space="preserve">
    <value>Вызванный код вызвал исключение, которое было перехвачено, но значение исключения было равно NULL</value>
  </data>
  <data name="InvalidClassCleanupLifecycleValue" xml:space="preserve">
    <value>Для параметра "ClassCleanupLifecycle" указано недопустимое значение "{0}". Поддерживаемые области: {1}.</value>
  </data>
  <data name="ClassInitializeTimedOut" xml:space="preserve">
    <value>Истекло время ожидания метода инициализации класса "{0}.{1}"</value>
  </data>
  <data name="CannotRunTestMethodNoDataError" xml:space="preserve">
    <value>Не удается запустить метод теста "{0}.{1}": метод имеет параметры, но не определяет источник теста. Используйте "[DataRow]", "[DynamicData]" или настраиваемый источник данных "ITestDataSource" для предоставления тестовых данных.</value>
  </data>
  <data name="UTA_ErrorMultiInit" xml:space="preserve">
    <value>UTA018: {0}: невозможно определить несколько методов с атрибутом TestInitialize.</value>
  </data>
  <data name="TestAssembly_AssemblyDiscoveryFailure" xml:space="preserve">
    <value>Не удалось обнаружить тесты из сборки {0}. Причина:{1}</value>
  </data>
  <data name="UTA_ErrorNonPublicTestClass" xml:space="preserve">
    <value>UTA001: атрибут TestClass определен в классе {0}, не являющемся открытым</value>
  </data>
  <data name="UTA_ErrorIncorrectTestMethodSignature" xml:space="preserve">
    <value>UTA007: метод {1}, определенный в классе {0}, имеет неправильную сигнатуру. Метод теста, помеченный атрибутом [TestMethod], должен быть нестатическим, открытым и иметь тип возвращаемого значения void; он также не должен принимать параметры. Пример: public void Test.Class1.Test(). Кроме того, при использовании async-await в методе теста возвращаемое значение должно иметь тип "Task" или "ValueTask". Пример: public async Task Test.Class1.Test2()</value>
  </data>
  <data name="UTA_ErrorTestPropertyNullOrEmpty" xml:space="preserve">
    <value>UTA021: {0}: в методе {1} определено пользовательское свойство, имя которого имеет значение NULL или пусто. Пользовательское свойство должно иметь допустимое имя.</value>
  </data>
  <data name="UTA_NoTestResult" xml:space="preserve">
    <value>Ошибка при выполнении теста. Расширение не возвратило результаты. Если используется расширение атрибута TestMethodAttribute, обратитесь к поставщику.</value>
  </data>
  <data name="CannotRunTestArgumentsMismatchError" xml:space="preserve">
    <value>Не удается запустить метод теста "{0}.{1}": тестовые данные не соответствуют параметрам метода. Количество или типы отличаются.
Число ожидаемых для теста параметров: {2} с типами "{3}",
но число полученных аргументов: {4} с типами "{5}".</value>
  </data>
  <data name="UTA_ClassCleanupMethodWasUnsuccesful" xml:space="preserve">
    <value>Не удалось применить метод очистки класса {0}.{1}. Сообщение об ошибке: {2}. Трассировка стека: {3}.</value>
  </data>
  <data name="CannotExpandIDataSourceAttribute_DuplicateDisplayName" xml:space="preserve">
    <value>Отображаемые имена "{2}" в индексах {0} и {1} дублируются. Отображаемые имена должны быть уникальными.</value>
  </data>
  <data name="AssemblyCleanupTimedOut" xml:space="preserve">
    <value>Истекло время ожидания метода очистки сборки "{0}.{1}"</value>
  </data>
  <data name="SourcesNotSupported" xml:space="preserve">
    <value>Запуск тестов в любом из предоставленных источников не поддерживается на выбранной платформе</value>
  </data>
  <data name="OlderTFMVersionFound" xml:space="preserve">
    <value>В сборку загружена старая версия пакета MSTestV2. При обнаружении тестов могут быть обнаружены не все тесты данных, если они зависят от файла ".runsettings".</value>
  </data>
  <data name="UTA_ClassInitMethodThrows" xml:space="preserve">
    <value>Методом инициализации класса {0}.{1} создано исключение. {2}: {3}.</value>
  </data>
  <data name="ExceptionsThrown" xml:space="preserve">
    <value>Выданные исключения:</value>
  </data>
  <data name="TestContextIsNull" xml:space="preserve">
    <value>TestContext не может иметь значение NULL.</value>
  </data>
  <data name="DataDrivenResultDisplayName" xml:space="preserve">
    <value>{0} (строка данных {1})</value>
  </data>
  <data name="UTA_WrongThread" xml:space="preserve">
    <value>{0} В проектах UWP, если в тесте используются объекты пользовательского интерфейса, рассмотрите возможность использования атрибута [UITestMethod] вместо атрибута [TestMethod] для выполнения теста в потоке пользовательского интерфейса.</value>
  </data>
  <data name="TestInitializeTimedOut" xml:space="preserve">
    <value>Истекло время ожидания метода инициализации теста "{0}.{1}"</value>
  </data>
  <data name="UTA_ExecuteThrewException" xml:space="preserve">
    <value>При выполнении теста возникло исключение. Если используется расширение атрибута TestMethodAttribute, обратитесь к поставщику. Сообщение об ошибке: {0}. Трассировка стека: {1}</value>
  </data>
  <data name="ClassInitializeWasCancelled" xml:space="preserve">
    <value>Метод инициализации класса "{0}.{1}" отменен</value>
  </data>
  <data name="UTA_TestMethodThrows" xml:space="preserve">
    <value>Метод теста {0}.{1} создал исключение: 
{2}.</value>
  </data>
  <data name="AssemblyInitializeWasCancelled" xml:space="preserve">
    <value>Метод инициализации сборки "{0}.{1}" отменен</value>
  </data>
  <data name="UTA_CleanupMethodThrows" xml:space="preserve">
    <value>Метод TestCleanup {0}.{1} создал исключение. {2}.</value>
  </data>
  <data name="UTA_InstanceCreationError" xml:space="preserve">
    <value>Не удалось создать экземпляр класса {0}. Ошибка: {1}.</value>
  </data>
  <data name="TestParallelizationBanner" xml:space="preserve">
    <value>Исполнитель MSTest: включена параллелизация тестов для {0} (рабочие роли: {1}, область: {2}).</value>
  </data>
  <data name="UTA_TestContextTypeMismatchLoadError" xml:space="preserve">
    <value>Для свойства {0}.TestContext указан неправильный тип.</value>
  </data>
  <data name="DebugTraceBanner" xml:space="preserve">
    <value>Трассировка отладки:</value>
  </data>
  <data name="UTA_ClassOrAssemblyCleanupMethodHasWrongSignature" xml:space="preserve">
    <value>Метод {0}.{1} имеет неправильную сигнатуру. Метод должен быть статическим и открытым, не должен возвращать значение и принимать параметры. Кроме того, при использовании async-await в методе возвращаемое значение должно иметь тип "Task" или "ValueTask".</value>
  </data>
  <data name="UTA_ErrorGenericTestMethod" xml:space="preserve">
    <value>UTA015: универсальный метод не может быть методом теста. {0}.{1} имеет недопустимую сигнатуру</value>
  </data>
  <data name="UTA_AssemblyInitMethodThrows" xml:space="preserve">
    <value>Методом инициализации сборки {0}.{1} создано исключение. {2}: {3}. Выполнение теста прекращается.</value>
  </data>
  <data name="UTA_ErrorMultiClean" xml:space="preserve">
    <value>UTA024: {0}: невозможно определить несколько методов с атрибутом TestCleanup.</value>
  </data>
  <data name="InvalidParallelScopeValue" xml:space="preserve">
    <value>В поле "Область" указано недопустимое значение "{0}". Поддерживаемые области: {1}.</value>
  </data>
  <data name="TestInitializeWasCancelled" xml:space="preserve">
    <value>Метод инициализации теста "{0}.{1}" отменен</value>
  </data>
  <data name="AssemblyInitializeTimedOut" xml:space="preserve">
    <value>Истекло время ожидания метода инициализации сборки "{0}.{1}"</value>
  </data>
  <data name="UTF_FailedToGetExceptionMessage" xml:space="preserve">
    <value>(Не удалось получить сообщение для исключения с типом {0} в связи с возникновением исключения.)</value>
  </data>
  <data name="AttachmentSetDisplayName" xml:space="preserve">
    <value>MSTestAdapterV2</value>
  </data>
  <data name="CouldNotInspectTypeDuringDiscovery" xml:space="preserve">
    <value>Средству MSTestAdapter не удалось обнаружить тесты в классе "{0}" сборки "{1}", так как {2}.</value>
  </data>
  <data name="UTA_TestContextSetError" xml:space="preserve">
    <value>Не удалось задать свойство TestContext для класса {0}. Ошибка: {1}.</value>
  </data>
  <data name="UTA_ErrorMultiAssemblyClean" xml:space="preserve">
    <value>UTA014: {0}: в сборке невозможно определить несколько методов с атрибутом AssemblyCleanup.</value>
  </data>
  <data name="UTA_FailedToGetTestMethodException" xml:space="preserve">
    <value>Не удалось получить исключение, созданное методом теста {0}.{1}.</value>
  </data>
  <data name="InvalidParallelWorkersValue" xml:space="preserve">
    <value>В поле "Рабочие роли" указано недопустимое значение "{0}". Оно должно быть неотрицательным целым числом.</value>
  </data>
  <data name="UTA_EndOfInnerExceptionTrace" xml:space="preserve">
    <value>--- Конец трассировки стека внутренних исключений ---</value>
  </data>
  <data name="UTA_ErrorInvalidTimeout" xml:space="preserve">
    <value>UTA054: {0}.{1} имеет недопустимый атрибут Timeout. Время ожидания должно быть допустимым целым числом и не может быть меньше 0.</value>
  </data>
  <data name="LegacyScenariosNotSupportedWarning" xml:space="preserve">
    <value>Внимание! Адаптер MSTest версии 2 не поддерживает файл TESTSETTINGS или VSMDI.</value>
  </data>
  <data name="UTA_NoDefaultConstructor" xml:space="preserve">
    <value>Не удается получить конструктор по умолчанию для класса {0}.</value>
  </data>
  <data name="UTA_TestContextLoadError" xml:space="preserve">
    <value>Не удается найти свойство {0}.TestContext. Ошибка: {1}.</value>
  </data>
  <data name="ClassCleanupTimedOut" xml:space="preserve">
    <value>Истекло время ожидания метода очистки класса "{0}.{1}"</value>
  </data>
  <data name="EnumeratorLoadTypeErrorFormat" xml:space="preserve">
    <value>{0}: {1}</value>
  </data>
  <data name="UTA_MultipleExpectedExceptionsOnTestMethod" xml:space="preserve">
    <value>В методе теста {0}.{1} определено несколько атрибутов, производных от ExpectedExceptionBaseAttribute, заданного в нем. Допускается только один такой атрибут.</value>
  </data>
  <data name="UTA_ErrorInValidTestContextSignature" xml:space="preserve">
    <value>UTA031: в классе {0} отсутствует допустимое свойство TestContext. Свойство TestContext должно иметь тип TestContext, быть нестатическим, открытым и не должно быть предназначено только для чтения. Например: public TestContext TestContext.</value>
  </data>
  <data name="UTA_CleanupMethodThrowsGeneralError" xml:space="preserve">
    <value>Ошибка при вызове метода TestCleanup для тестового класса {0}: {1}</value>
  </data>
  <data name="UTA_MethodDoesNotExists" xml:space="preserve">
    <value>Метод {0}.{1} не существует.</value>
  </data>
  <data name="TestAssembly_FileDoesNotExist" xml:space="preserve">
    <value>Файл не существует: {0}</value>
  </data>
  <data name="CannotExpandIDataSourceAttribute_CannotSerialize" xml:space="preserve">
    <value>Не удается сериализовать данные в индексе {0} для "{1}". Все данные, предоставленные через IDataSource, должны быть сериализуемыми. Если необходимо протестировать несериализуемые источники данных, добавьте атрибут "TestDataSourceDiscovery" в тестовую сборку и установите для параметра обнаружения значение "DuringExecution".</value>
  </data>
  <data name="FailedToGetCustomAttribute" xml:space="preserve">
    <value>При получении настраиваемых атрибутов для типа {0} возникло исключение (оно будет проигнорировано и будет использовано отражение): {1}</value>
  </data>
  <data name="UTA_CleanupStackTrace" xml:space="preserve">
    <value>Трассировка стека TestCleanup</value>
  </data>
  <data name="UTA_TypeLoadError" xml:space="preserve">
    <value>Не удается получить тип {0}. Ошибка: {1}.</value>
  </data>
  <data name="TypeLoadFailed" xml:space="preserve">
    <value>Не удалось загрузить типы из тестового источника "{0}". В этом источнике могут быть не обнаружены некоторые или все тесты.
Ошибка: {1}</value>
  </data>
  <data name="STAIsOnlySupportedOnWindowsWarning" xml:space="preserve">
    <value>Запись Runsettings "&lt;ExecutionApartmentState&gt;STA&lt;/ExecutionApartmentState&gt;" не поддерживается в ОС, отличных от Windows.</value>
  </data>
  <data name="UTA_ErrorMultiClassClean" xml:space="preserve">
    <value>UTA026: {0}: в классе невозможно определить несколько методов с атрибутом ClassCleanup.</value>
  </data>
  <data name="FailedFetchAttributeCache" xml:space="preserve">
    <value>Не удалось получить кэш атрибутов. Наследование атрибутов игнорируется и выполняется переход к схеме "тип определяет модель атрибута", чтобы получить некоторые данные.</value>
  </data>
</root>