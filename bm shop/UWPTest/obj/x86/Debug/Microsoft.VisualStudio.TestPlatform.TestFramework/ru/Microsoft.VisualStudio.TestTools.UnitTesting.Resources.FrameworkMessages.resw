<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ElementNumbersDontMatch" xml:space="preserve">
    <value>Число элементов в наборе не соответствует ожидаемому. Ожидается: &lt;{1}&gt;. Фактически: &lt;{2}&gt;.{0}</value>
  </data>
  <data name="IsMatchFail" xml:space="preserve">
    <value>Строка "{0}" не соответствует шаблону "{1}". {2}.</value>
  </data>
  <data name="IsInstanceOfFailMsg" xml:space="preserve">
    <value>{0}Ожидается тип: &lt;{1}&gt;. Фактический тип: &lt;{2}&gt;.</value>
  </data>
  <data name="ContainsFail" xml:space="preserve">
    <value>Строка "{0}" не содержит строку "{1}". {2}.</value>
  </data>
  <data name="StartsWithFail" xml:space="preserve">
    <value>Строка "{0}" не начинается со строки "{1}". {2}.</value>
  </data>
  <data name="AreEqualDifferentTypesFailMsg" xml:space="preserve">
    <value>Ожидается: &lt;{1} ({2})&gt;. Фактически: &lt;{3} ({4})&gt;. {0}</value>
  </data>
  <data name="DynamicDataInvalidPropertyLayout" xml:space="preserve">
    <value>Свойство динамических данных "{0}" должно быть статическим и иметь метод получения.</value>
  </data>
  <data name="BothSameElements" xml:space="preserve">
    <value>Обе коллекции содержат одинаковые элементы. {0}</value>
  </data>
  <data name="DynamicDataValueNull" xml:space="preserve">
    <value>Значение, возвращаемое свойством или методом {0}, не должно быть равно NULL.</value>
  </data>
  <data name="AreNotEqualDeltaFailMsg" xml:space="preserve">
    <value>Между ожидаемым значением &lt;{1}&gt; и фактическим значением &lt;{2}&gt; требуется разница более чем &lt;{3}&gt;. {0}</value>
  </data>
  <data name="ElementsAtIndexDontMatch" xml:space="preserve">
    <value>Элемент по индексу {0} не совпадает.</value>
  </data>
  <data name="BothCollectionsSameReference" xml:space="preserve">
    <value>Ссылки в обоих коллекциях указывают на один и тот же объект коллекции. {0}</value>
  </data>
  <data name="AsyncUITestMethodNotSupported" xml:space="preserve">
    <value>Асинхронный метод TestMethod с UITestMethodAttribute не поддерживается. Удалите префикс async или используйте TestMethodAttribute.</value>
  </data>
  <data name="PrivateAccessorConstructorNotFound" xml:space="preserve">
    <value>
      Не удается найти конструктор с указанной сигнатурой. Возможно, требуется снова создать закрытый 
      метод доступа либо член является закрытым и определенным на основе базового класса. Если 
      справедливо последнее, то необходимо передать тип, определяющий член, в конструктор для PrivateObject.
    </value>
  </data>
  <data name="AssertionFailed" xml:space="preserve">
    <value>Сбой {0}. {1}</value>
  </data>
  <data name="DoNotUseAssertEquals" xml:space="preserve">
    <value>Нельзя использовать Assert.Equals для Assertions. Вместо этого используйте Assert.AreEqual и перегрузки.</value>
  </data>
  <data name="UTF_TestMethodNoExceptionDefault" xml:space="preserve">
    <value>Метод теста не создал исключение. Исключение ожидалось атрибутом {0}, определенным в методе теста.</value>
  </data>
  <data name="Common_NullInMessages" xml:space="preserve">
    <value>(NULL)</value>
  </data>
  <data name="UTF_TestMethodWrongExceptionDerivedAllowed" xml:space="preserve">
    <value>Метод теста создал исключение "{0}", а ожидалось исключение "{1}" или производный от него тип. Сообщение исключения: "{2}".</value>
  </data>
  <data name="NoExceptionThrown" xml:space="preserve">
    <value>Исключение не создано. Ожидалось исключение {1}. {0}</value>
  </data>
  <data name="DataDrivenResultDisplayName" xml:space="preserve">
    <value>{0} ({1})</value>
  </data>
  <data name="CollectionEqualReason" xml:space="preserve">
    <value>{0}({1})</value>
  </data>
  <data name="AccessStringInvalidSyntax" xml:space="preserve">
    <value>Строка доступа имеет недопустимый синтаксис.</value>
  </data>
  <data name="ElementTypesAtIndexDontMatch" xml:space="preserve">
    <value>Тип элемента по индексу {1} не соответствует ожидаемому. Ожидаемый тип: &lt;{2}&gt;. Фактический тип: &lt;{3}&gt;.{0}</value>
  </data>
  <data name="AreNotEqualFailMsg" xml:space="preserve">
    <value>Ожидается любое значение, кроме: &lt;{1}&gt;. Фактически: &lt;{2}&gt;. {0}</value>
  </data>
  <data name="AsyncUITestMethodWithNoDispatcherQueue" xml:space="preserve">
    <value>Параметр UITestMethodAttribute.DispatcherQueue не должен иметь значение NULL. Чтобы использовать параметр UITestMethodAttribute в классических приложениях WinUI, не забудьте задать статический параметр UITestMethodAttribute.DispatcherQueue во время инициализации теста.</value>
  </data>
  <data name="UTF_TestMethodNoException" xml:space="preserve">
    <value>Метод теста не создал ожидаемое исключение ({0}). {1}</value>
  </data>
  <data name="IsNotMatchFail" xml:space="preserve">
    <value>Строка "{0}" соответствует шаблону "{1}". {2}.</value>
  </data>
  <data name="UTF_TestMethodWrongException" xml:space="preserve">
    <value>Метод теста создал исключение "{0}", а ожидалось исключение "{1}". Сообщение исключения: "{2}".</value>
  </data>
  <data name="WrongExceptionThrown" xml:space="preserve">
    <value>Создано исключение {2}, хотя ожидалось исключение {1}. {0}
Сообщение исключения: {3}
Трассировка стека: {4}.</value>
  </data>
  <data name="IsNotInstanceOfFailMsg" xml:space="preserve">
    <value>Неверный тип: &lt;{1}&gt;. Фактический тип: &lt;{2}&gt;. {0}</value>
  </data>
  <data name="AreEqualDeltaFailMsg" xml:space="preserve">
    <value>Между ожидаемым значением &lt;{1}&gt; и фактическим значением &lt;{2}&gt; требуется разница не более чем &lt;{3}&gt;. {0}</value>
  </data>
  <data name="UTF_FailedToGetExceptionMessage" xml:space="preserve">
    <value>(Не удалось получить сообщение для исключения с типом {0} в связи с возникновением исключения.)</value>
  </data>
  <data name="AllItemsAreUniqueFailMsg" xml:space="preserve">
    <value>Обнаружен совпадающий элемент: &lt;{1}&gt;. {0}</value>
  </data>
  <data name="Common_ObjectString" xml:space="preserve">
    <value>(объект)</value>
  </data>
  <data name="ArgumentXMustDeriveFromClassY" xml:space="preserve">
    <value>Тип "{0}" не может быть назначен "{1}".</value>
  </data>
  <data name="EndsWithFail" xml:space="preserve">
    <value>Строка "{0}" не оканчивается строкой "{1}". {2}.</value>
  </data>
  <data name="DynamicDataIEnumerableEmpty" xml:space="preserve">
    <value>Свойство или метод {0} класса {1} возвращает пустой IEnumerable&lt;object[]&gt;.</value>
  </data>
  <data name="DynamicDataInvalidMethodLayout" xml:space="preserve">
    <value>Метод динамических данных "{0}" должен быть статическим, не иметь параметров и быть неуниверсальным.</value>
  </data>
  <data name="NumberOfElementsDiff" xml:space="preserve">
    <value>Разное число элементов.</value>
  </data>
  <data name="NullParameterToAssert" xml:space="preserve">
    <value>Параметр "{0}" является недопустимым. Значение не может быть NULL. {1}.</value>
  </data>
  <data name="BothCollectionsSameElements" xml:space="preserve">
    <value>Обе коллекции содержат одинаковые элементы.</value>
  </data>
  <data name="BothCollectionsEmpty" xml:space="preserve">
    <value>Обе коллекции пусты. {0}</value>
  </data>
  <data name="AreEqualCaseFailMsg" xml:space="preserve">
    <value>Ожидается: &lt;{1}&gt;. Отличается на фактическое значение: &lt;{2}&gt;. {0}</value>
  </data>
  <data name="InvalidPropertyType" xml:space="preserve">
    <value>Свойство {0} имеет тип {1}. Ожидается тип {2}.</value>
  </data>
  <data name="AreSameGivenValues" xml:space="preserve">
    <value>Не передавайте типы значений в функцию AreSame(). Значения, преобразованные в Object, никогда не будут одинаковыми. Попробуйте использовать AreEqual(). {0}</value>
  </data>
  <data name="DynamicDataIEnumerableNull" xml:space="preserve">
    <value>Свойство или метод {0} возвращаемого типа {1} не могут быть назначены объекту "IEnumerable&lt;[]&gt;" (или "IEnumerable&lt;ITuple&gt;" для .NET Core).</value>
  </data>
  <data name="UTF_ExpectedExceptionTypeMustDeriveFromException" xml:space="preserve">
    <value>Тип ожидаемого исключения должен быть System.Exception или производным от System.Exception.</value>
  </data>
  <data name="DynamicDataDisplayName" xml:space="preserve">
    <value>Метод {0} должен соответствовать ожидаемой сигнатуре: public static {1} {0}({2}).</value>
  </data>
  <data name="AreEqualFailMsg" xml:space="preserve">
    <value>Ожидается: &lt;{1}&gt;. Фактически: &lt;{2}&gt;. {0}</value>
  </data>
  <data name="ActualHasMismatchedElements" xml:space="preserve">
    <value>Ожидаемый набор содержит следующее число событий &lt;{2}&gt;: {1}. Фактический набор содержит число событий: {3}. {0}</value>
  </data>
  <data name="PrivateAccessorMemberNotFound" xml:space="preserve">
    <value>
      Не удается найти указанный член ({0}). Возможно, требуется снова создать закрытый метод доступа
      либо член является закрытым и определенным на основе базового класса. Если справедливо последнее, то 
      необходимо передать тип, определяющий член, в конструктор для PrivateObject.
    </value>
  </data>
</root>